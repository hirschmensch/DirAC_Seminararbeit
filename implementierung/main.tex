In diesem Kapitel wird beschrieben, wie der DirAC-Algorithmus in diesem Projekt implementiert wurde. Die Implementierung liegt als Octave-Skript vor und nutzt das \textit{signal}-Package.

Zu Beginn des Skriptes wird das Eingangssignal im B-Format erster Ordnung eingelesene. Dies muss als \textit{.wav}-Datei vorliegen und genau vier Kanäle (in der Reihenfolge $w$, $x$, $y$, $z$) umfassen. Die Samplerate wird direkt aus dieser Datei ermittelt und als Variable \textit{fs} im Skript gespeichert. Anschließend wird eine VBAP-Matrix, je nach vorgegebener Lautsprecherandordnung erzeugt. Diese Matrix wird in späterer Folge verwendet, um das Eingangssignal im B-Format, auf eine bestimmte Lautsprecheranordnung zu dekodieren. Es handelt sich dabei also um eine nicht-parametrische Dekodierung, die mit einer Anordnung von virtuellen Mikrofonen zu vergleichen ist. Die Lautsprecherpositionen können dabei als sphärische Koordinaten in einer Matrix vorliegen, oder auch aus einer Textdatei mit kartesischen Koordinaten eingelesen werden. Diese Textdatei muss eine Matrix mit genau drei Spalten (Raumdimensionen) enthalten, wobei diese Spalten untereinander angeordnet sein müssen. Es befinden sich demnach genau die dreifache Anzahl der Lautsprecher als Zeilen in dieser Datei. Die Koordinaten sind dabei Meterangaben als Dezimalwerte. Das Einlesen von kartisischen Koordinaten ist speziell für die Dekodierung auf größere T-Designs äußerst nützlich.

Die vier Kanäle $w[n]$, $x[n]$, $y[n]$ und $z[n]$ des B-Format Eingangssginals werden anschließend in einer Schleife in zeitlichen Blöcken (Fenster) verarbeitet. Ein Fenster besteht dabei aus jeweils 512 Samples und wird in einer 1024-Punkt Fouriertransformation mit der Hilfe der Funktion \textit{fft()} in den Frequenzbereich transformiert. Die FFT-Länge wurde als doppelte Blocklänge gewählt um Aliasing zu vermeiden. Die zeitlichen Fenster werden noch mit einer Hanning-Fensterfunktion für die Resynthese beaufschlagt. Ein Hanning-Fenster kann in Octave mit der Funktion \textit{hanning()} erzeugt werden und einfach als Vektor mit den Zeitsignalen multipliziert werden.