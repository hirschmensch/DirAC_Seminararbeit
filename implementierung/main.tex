In diesem Kapitel wird beschrieben, wie der DirAC-Algorithmus in diesem Projekt implementiert wurde. Die Implementierung erfolgte als Octave-Skript und nutzt das \textit{signal}-Package.

Zu Beginn werden verschiedene Parameter und Arrays initialisiert, sowie auch eine VBAP-Matrix, je nach vorgegebener Lautsprecherandordnung berechnet. Diese Matrix wird in späterer Folge zu Dekodierung des Eingangssignals im B-Format erster Ordnung auf eine bestimmte Lautsprecheranordnung verwendet. Es handelt sich dabei also um eine nicht-parametrische Dekodierung die einer Anordnung von virtuellen Mikrofonen gleichzusetzen ist. Die Lautsprecherpositionen können dabei als sphärische Koordinaten, oder auch aus einer Textdatei mit kartisischen Koordinaten eingelesen werden. Das Einlesen von kartisischen Koordinaten ist speziell für die Dekodierung auf größere T-Designs äußerst nützlich.

Das Eingangssignal liegt als B-Format erster Ordnung vor und wird aus einer .wav-Datei eingelesen. Die vier Kanäle $w[n]$, $x[n]$, $y[n]$ und $z[n]$ werden anschließend in einer Schleife in zeitliche Blöcke von jeweils 512 Samples unterteilt und mit einer 1024-Punkt FFT in den Frequenzbereich transformiert. Die FFt-Länge ist als Doppelte Fensterlänge gewählt um Aliasing zu vermeiden und die zeitlichen Fenster werden noch mit einer Hanning-Fensterfunktion für die Resynthese beaufschlagt.